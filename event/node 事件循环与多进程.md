# 1.事件循环介绍

## 1.1 浏览器中的事件训话

> 问了协调事件(event)、用户交互、脚本、渲染、网络等，用户代理必须使用事件循环

- 事件：PostMessage、MutationObserve等
- 用户交互：click、onScroll等
- 渲染：解析DOM、CSS等
- 脚本：js执行

## 1.2 node中的事件循环

> 事件循环允许node执行非阻塞I/O操作 — 尽管js是单线程的 — 通过尽可能将操作卸载到系统内核，由于大多数现代内核都是多线程的、因此他们可以处理在后台执行的多个操作、当其中一个操作完成时、内核会告诉node、以便可以将相应的回调添加到轮询队列中以最终执行

- 事件：EventEmitter
- 非阻塞I/O：网络请求、文件读写等
- 脚本：js执行

## 1.3 事件循环本质

> 在浏览器或者node环境中、运行时对js脚本的调度方式就叫做事件循环

# 2.浏览器事件循环

## 2.1 js为什么是单线程？

> 浏览器的js主要作用之一是操作DOM、因此决定了它只能是单线程、否则会带来很复杂的同步问题，比如：假定js同时有两个线程、一个线程在某个DOM节点上添加内容、另一个线程删除了这个节点、这时浏览器应该以那个线程为准？懵逼…...

## 2.2任务队列

> 单线程就意味着所有任务需要排队、如果因为任务cpu计算量大还好、但是I/O操作cpu时闲着的、所以js就设计成了一门一步语言、不会做无谓的等待。任务可以分成两种：同步任务和异步任务

1. 所有同步任务都在主线程上执行、形成一个`执行栈`
2. 主线程之外、还存在一个`任务队列` 、只要异步任务有了运行结果、就会在`任务队列`中放置一个事件
3. 一旦`执行栈`中的所有同步任务执行完毕、系统就会读取`任务队列`、看看里面有哪些事件、哪些对应的异步任务、于是结束等待状态、进入执行栈、开始执行
4. 主线程不断重复上面的第三步

> 主线程从`任务队列`中读取事件、这个过程时循环不断的、因为这种运行机制又称为 event loop

## 3.3 宏任务、微任务

> 除了广义的同步任务和异步任务、js单线程中的任务还可以细分为宏任务和微任务

- macrotast 宏任务：script(整体代码)、setTimeout、setInterval、setImmediate、I/O、ui renderinh
- microtast 微任务：process.nextTick、Promise、Object.observe、MutationObserve

1. 宏任务进入主线程、执行过程中会收集微任务加入微任务队列
2. 宏任务执行完成之后、立马执行微任务中的任务、微任务执行过程中将再次收集宏任务并加入宏任务队列
3. 反复执行1、2步骤

> 每执行完一轮宏任务和微任务就叫做事件循环

> 一轮事件循环会执行一次宏任务以及所有的微任务

> 任务队列一定会保持先进先出的顺序执行